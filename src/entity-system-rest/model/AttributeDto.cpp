/**
 * Inexor Entity System
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 3.0.0
 * Contact: info@inexor.org
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.0.0-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "AttributeDto.hpp"

#include <string>
#include <sstream>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;

namespace inexor {
namespace entity_system {
namespace rest {
namespace model {

//	AttributeDto::AttributeDto()
//	{
//	}

	AttributeDto::AttributeDto(const DataType& type, const DataValue& value, const EnumSet<Feature>& features)
		: DataContainer(type, value),
		  features(features)
	{
	}

	AttributeDto::AttributeDto(const std::string& attribute_uuid, const std::string& name, const DataType& type, const DataValue& value, const EnumSet<Feature>& features)
		: attribute_uuid(attribute_uuid),
		  name(name),
		  DataContainer(type, value),
		  features(features)
	{
	}

	AttributeDto::~AttributeDto()
	{
	}

	std::string AttributeDto::to_json_string()
	{
		std::stringstream ss;
		ptree pt;
		pt.put("attribute_uuid", attribute_uuid);
		pt.put("name", name);
		pt.put("datatype", type._to_string());
		ptree pt_attribute_features;
		for (Feature feature : Feature::_values())
		{
			if (features.test(feature))
			{
				ptree pt_attribute_feature;
				pt_attribute_feature.put("", feature._to_string());
				pt_attribute_features.push_back(std::make_pair("", pt_attribute_feature));
			}
		}
		pt.add_child("features", pt_attribute_features);
		switch (type)
		{
			case DataType::BOOL:
				pt.put("value", std::get<DataType::BOOL>(value.Value()));
				break;
			case DataType::INT:
				pt.put("value", std::get<DataType::INT>(value.Value()));
				break;
			case DataType::BIG_INT:
				pt.put("value", std::get<DataType::BIG_INT>(value.Value()));
				break;
			case DataType::DOUBLE:
				pt.put("value", std::get<DataType::DOUBLE>(value.Value()));
				break;
			case DataType::FLOAT:
				pt.put("value", std::get<DataType::FLOAT>(value.Value()));
				break;
			case DataType::STRING:
				pt.put("value", std::get<DataType::STRING>(value.Value()));
				break;
//			case DataType::VEC3:
//				pt.put("value", std::get<DataType::VEC3>(value.Value());
//				break;
//			case DataType::VEC4:
//				pt.put("value", std::get<DataType::VEC4>(value.Value());
//				break;
			default:
				pt.put("value", 0);
				break;
		}
		write_json(ss, pt, false);
		return ss.str();
	}

	void AttributeDto::from_json_string(std::string const& jsonString)
	{
		std::stringstream ss(jsonString);
		ptree pt;
		read_json(ss,pt);
		attribute_uuid = pt.get("attribute_uuid", "");
		name = pt.get("name", "");
		std::string datatype = pt.get("datatype", "");
		type = DataType::_from_string(datatype.c_str());
		switch (type)
		{
			case DataType::BOOL:
			{
				bool bool_value = pt.get("value", false);
//				value.Set(bool_value);
				break;
			}
			case DataType::INT:
			{
				int int_value = pt.get("value", 0);
//				value.Set(int_value);
				break;
			}
			case DataType::BIG_INT:
			{
				std::int64_t big_int_value = pt.get("value", 0);
//				value.Set(big_int_value);
				break;
			}
			case DataType::DOUBLE:
			{
				double double_value = pt.get("value", 0.0);
//				value.Set(double_value);
				break;
			}
			case DataType::FLOAT:
			{
				double float_value = pt.get("value", 0.0f);
//				value.Set(float_value);
				break;
			}
			case DataType::STRING:
			{
				std::string string_value = pt.get("value", "");
//				value.Set(string_value);
				break;
			}
//			case DataType::VEC3:
//			case DataType::VEC4:
			default:
			{
				break;
			}
		}
	}

	std::string AttributeDto::get_attribute_uuid() const
	{
		return attribute_uuid;
	}

	void AttributeDto::set_attribute_uuid(const std::string& attribute_uuid)
	{
		this->attribute_uuid = attribute_uuid;
	}

	std::string AttributeDto::get_name() const
	{
		return name;
	}

	void AttributeDto::set_name(const std::string& name)
	{
		this->name = name;
	}

	DataType AttributeDto::get_type() const
	{
		return type;
	}

	void AttributeDto::set_type(const DataType& type)
	{
		this->type = type;
	}

	DataValue AttributeDto::get_value() const
	{
		return value.Value();
	}

	void AttributeDto::set_value(const DataValue& value)
	{
//		this->value.Set(value);
	}

	EnumSet<Feature> AttributeDto::get_features() const
	{
		return features;
	}

	void AttributeDto::set_features(const EnumSet<Feature>& features)
	{
		this->features = features;
	}

}
}
}
}

